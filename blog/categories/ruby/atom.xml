<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | A Boy~]]></title>
  <link href="http://davidqin.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://davidqin.github.com/"/>
  <updated>2013-01-03T11:45:27+08:00</updated>
  <id>http://davidqin.github.com/</id>
  <author>
    <name><![CDATA[David Qin]]></name>
    <email><![CDATA[davidqhr@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ruby对象模型]]></title>
    <link href="http://davidqin.github.com/blog/2012/08/08/ruby-dui-xiang-mo-xing/"/>
    <updated>2012-08-08T00:00:00+08:00</updated>
    <id>http://davidqin.github.com/blog/2012/08/08/ruby-dui-xiang-mo-xing</id>
    <content type="html"><![CDATA[<p>摘抄《Ruby元编程》</p>

<p>读完这书，有种豁然开朗的感觉，尤其是那几个图片。
以下是书中对ruby对象模型的总结，一共7条，我这里写了6条，括号中为我的理解</p>

<p>只有一种对象——要么是普通对象，要么是模块</p>

<p>只有一种模块——可以是普通模块、类、单例类、eigenclass、代理类</p>

<p>只有一个方法——存在模块或类中
（所谓的类方法，无非是它eigenclass的实例方法）</p>

<p>每个对象（普通对象，类）都有自己的“真正的类”——要么是普通类，要么是eigenclass</p>

<p>除了BasicObject(1.8中为Object)无超类外，每个类只有一个超类
（这里有个很有趣的事，BasicObject的eigenclass的超类是Class）</p>

<p>一个对象的eigenclass的超类是这个对象的类；一个类的eigenclass的超类事这个类的超类的eigenclass。
（子类继承父类类方法的原理）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ruby 先有鸡还是先有蛋问题]]></title>
    <link href="http://davidqin.github.com/blog/2012/08/08/ruby--xian-you-ji-huan-shi-xian-you-dan-wen-ti/"/>
    <updated>2012-08-08T00:00:00+08:00</updated>
    <id>http://davidqin.github.com/blog/2012/08/08/ruby--xian-you-ji-huan-shi-xian-you-dan-wen-ti</id>
    <content type="html"><![CDATA[<p>困惑了很久，一篇文章终于让我豁然开朗，终于不憋了！！！</p>

<p>出处：http://www.blogjava.net/killme2008/archive/2007/09/29/149452.html</p>

<p>附图
<a href="http://qinhru-wordpress.stor.sinaapp.com/uploads/2012/08/ch_class_metaobj.png"><img src="http://qinhru-wordpress.stor.sinaapp.com/uploads/2012/08/ch_class_metaobj-300x163.png" alt="" title="ch_class_metaobj" width="300" height="163" class="alignnone size-medium wp-image-402"></a></p>

<p>1、
ruby在底层做了处理，instance的class在ruby层次是(instance),当查找的时候忽略了singleton类以及下面将要谈到的include模块的代理类，沿着继承链上查找
其中FL_TEST(cl,FL_SINGLETON)用于测试是否是singleton类，而TYPE(cl)==TL_ICLASS是否是包含模块的代理类，TL_ICLASS的I就是include的意思。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>VALUE
</span><span class='line'> rb_obj_class(obj)
</span><span class='line'> VALUE obj;
</span><span class='line'> {
</span><span class='line'> return rb_class_real(CLASS_OF(obj));
</span><span class='line'> }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p> VALUE
</span><span class='line'> rb_class_real(cl)
</span><span class='line'> VALUE cl;
</span><span class='line'> {
</span><span class='line'> while (FL_TEST(cl, FL_SINGLETON) || TYPE(cl) == T_ICLASS) {
</span><span class='line'> cl = RCLASS(cl)->super;
</span><span class='line'> }
</span><span class='line'> return cl;
</span><span class='line'> }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>2、
图中类OtherClass继承Object，这个是显而易见的，不再多说。而Object、Class和Module这三个类是没办法通过API创建的，称为元类，他们的之间的关系如图所示，Object的class是Class,Module继承Object,而Class又继承Module，因此Class.kind_of? Object返回true,这个问题类似先有鸡，还是先有蛋的问题，是先有Object？还是先有Class?而c ruby的解决办法是不管谁先有，创建Object开始，接着创建Module和Class，然后分别创建它们的metaclass，从此整个Ruby的对象模型开始运转。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>VALUE
</span><span class='line'> rb_obj_class(obj)
</span><span class='line'> VALUE obj;
</span><span class='line'> {
</span><span class='line'> return rb_class_real(CLASS_OF(obj));
</span><span class='line'> }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p> VALUE
</span><span class='line'> rb_class_real(cl)
</span><span class='line'> VALUE cl;
</span><span class='line'> {
</span><span class='line'> while (FL_TEST(cl, FL_SINGLETON) || TYPE(cl) == T_ICLASS) {
</span><span class='line'> cl = RCLASS(cl)->super;
</span><span class='line'> }
</span><span class='line'> return cl;
</span><span class='line'> }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>那么当我们调用Class.class发生了什么？Class的klass其实指向的是(Class)，可根据上面的代码，我们知道会忽略这个(Class)，继续往上找就是(Module),同理找到(Object)，而(Object)继承自Class,显然Class的类仍然是Class，Class的类的类也是Class,多么有趣。同理，Object.class和Module.class都将是Class类。</p>

<p>3、
 再来看看include模块时发生的故事。include模块的过程如下图所示：
<a href="http://qinhru-wordpress.stor.sinaapp.com/uploads/2012/08/ch_class_include.png"><img src="http://qinhru-wordpress.stor.sinaapp.com/uploads/2012/08/ch_class_include.png" alt="" title="ch_class_include" class="alignnone size-full wp-image-403"></a></p>

<p>include模块，本质上是在对象或者类的klass和super之间插入了一个代理类iclass,这个代理类的方法表(m_table)和变量表(iv_table)分别指向了被包含的模块的方法表和变量表（通过指针，因此当包含的Module变化的时候，对象或者类也能相应变化），那么在查找类或者对象的class的时候，上面已经说明将忽略这些代理类。</p>
]]></content>
  </entry>
  
</feed>
